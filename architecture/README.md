# Описание архитектуры сервиса нотификаций

## Связь компонентов
[Ссылка на Miro](https://miro.com/welcomeonboard/VGJIcHM5MXZIdVFQM1JscFBVNTRpWXJiSFIxMEFrZGpKRDRjU05Wck5XZXZ5RkllQUhHZEhJd2pORGF3NmFaQ3wzNDU4NzY0NTI5MDgxMzEwMDYx?share_link_id=551609151149)
![](components.png)

## Схема базы данных
Храним данные в MongoDB в соответствии со входящей моделью событий. 
Важно!!! Не решили, как хранить обработанные данные - после обогащения кладем в MongoDB???

## Модели данных Notification API
### Входящие
```json
{
  "receivers_list": [user_id_1, user_id_2, ...],
  "sender": "str",
  "event_type": event_type,
  "transport": ["sms", "push"],
  "priority": 1,
  "created_dt": created_dt,
  "schedule": "5 4 * * *",
  "start_date": null,
  "payload": {
    "header": "str",
    "template": "str",
    "body": {...}
  }
}
```
где `event_type` представлен для типов событий:
- вышла новая серия
- лайк комментария
- реклама новинок
- напоминание об отложенных

`priority` - числовое значение приоритета уведомлений, 1 - самые срочные. Диапазон от 1 до 5.

`schedule`, `start_date` - cron-значение и дата старта для начала отсылки периодических уведомлений.

`payload` - информация для уведомления:
    `body` - словарь данных уведомления
    `template`* - шаблон для уведомления
    `header`* - хедер сообщения

### Исходящие (подготовленные для воркера)
```json
{
  "_id": "str", # сквозное id из mongodb
  "priority": 1,
  "type": "transactional" # scheduled/transactional
  "transport": {
    "email": {
      "address": "email",
      "message": msg_obj
    },
    "sms": {
      "number": "number",
      "message": "str"
    },
    "push": {
      "device": device_obj,
      "message": "str"
    }
  }
}
```

## Описание работы
### Notification Event API
1) Notification Event API (в дальнейшем просто API) является единой точкой входа для событий, по которым надо делать рассылку. 
Представляет собой асинхронный FastAPI-сервис с эндпоинтами:
   - регистрация события о нотификации по шаблону из пункта `Модели данных Notification API - Входящие`. *
   - получение нотификации на отправку в шину RabbitMQ
   - обновление статуса доставки сообщения
   - регистрация списков рассылки

2) После получения события API сохраняет данные в MongoDB.
3) Записывает данные в БД.
4) Отсылает на воркер через шину RabbitMQ.
!!! В данном проекте для генерации начальных событий будет написан генератор событий вместо доработки Auth API + UGC API + Admin Panel.

### Генератор периодических событий
1) Этот сервис так же, как и Notification Event API, является асинхронным FastAPI-сервис в связке с Celery как планировщиком.
(либо просто асинхронный сервис + Celery).
2) Данные для планирования берутся из MongoDB.
3) Данные обогащаются сервисом обогащения данных (может быть частью генератора)ю
4) Celery имеет 2 очереди - realtime/scheduled.
5) Планировщик должен уметь добавлять таски с динамически построенным расписанием 
(вычитывается из полей start_day, schedule в формате cron) в scheduled.
6) Планировщик должен уметь добавлять таски для отправки сообщений прямо сейчас в очередь realtime.
7) Celery при срабатывании расписания передает информацию генератору,
тот, в свою очередь, передает данные в Notification Event API.

### Сервис обогащения данных (может быть частью генератора периодических событий)
1) Получает запросы на обогащение данных, обрабатывает их, получает данные из Auth API + UGC API и передает дальше.
По сути, формирует конечную форму нотификаций (см `Исходящие (подготовленные для воркера)`).

### Шина данных RabbitMQ
1) Принимает информацию от Notification Event API и пересылает ее в воркер.
2) Имеет несколько очередей, разделенных по приоритетам уведомлений (поле priority).

### Воркер
1) Представляет собой обычный python-сервис, работающий в бесконечном цикле.
2) Асинхронно вычитывает разные очереди и в зависимости от типа посылает уведомления.
3) Воркер читает транспорт и по нему выбирает обработчик а-ля 
```t_class = TRANSPORTS[message["transport_name"]; t_class(message).send()```
